<?php

/**
 * @file
 * The Everyday Tools module houses functions that are useful in every Drupal build that requires
 * some degree of development. The functions range from string manipulation to theme helpers.
 */

/**
 * Returns the url of the requested image relative to the domain name, i.e. /sites/default/files....
 *
 * @param string $image_name - The name of the entity field to retrieve the image from, i.e. 'cover'.
 * @param object $entity - The entity object that contains the image
 * @param string $image_style - Optional - If you would like the returned path to have been styled with an image style
 * @return string - The path to the image relative to the domain name i.e. /sites/default/files/test.jpg
 */
function et_get_image($image_name, $entity, $style_name = NULL, $entity_type = 'node') {
  if (property_exists($entity, 'field_' . $image_name)) {
    if (!property_exists($entity, 'language')) {
      $entity->language = 'und';
    }
    $image = field_get_items($entity_type, $entity, 'field_' . $image_name, $entity->language);
    if ($image && $image[0]['uri']) {
      if ($style_name) {
        $image = strip_url(image_style_url($style_name, $image[0]['uri']));
      }
      else {
        $image = strip_url(file_create_url($image[0]['uri']));
      }
      if ($image) {
        return $image;
      }
    }
  }

  return NULL;
}

/**
 * Returns the summary if available or a trimmed version of an entity.
 *
 * @param object $entity - The entity object to retrieve the summary from
 * @param int $length - Optional - The number of characters to trim to (The word will be completed prior to trimming.)
 * @param string $delim - Optional - The delimiter to append to the summary if it's trimmed
 * @param string $field - Optional - The field to take the summary from.
 * @return string
 */
function et_summary($entity, $length = 200, $delim = '&hellip;', $field = 'body') {
  $field = field_get_items('node', $entity, $field, $entity->language);

  if (trim($field[0]['safe_summary'])) {
    return $field[0]['safe_summary'];
  }
  elseif ($field[0]['value']) {
    return neat_trim(strip_tags($field[0]['value']), $length, $delim);
  }
  else {
    return NULL;
  }
}

/**
 * Strip out the site domain from the string. This is important when adding outputting css, js and image links etc because
 * having the full URL leads to unnecessary server load.
 *
 * @global string $base_url
 * @param string $str
 * @return string
 */
function et_strip_url($str) {
  global $base_url;
  return str_replace($base_url, '', $str);
}

/**
 * Returns the path to the site theme after the TLD (e.g. .com). This is useful for inserting theme images etc into
 * template files as it does so without the full site url, saving unnecessary server load.
 *
 * @global string $base_url
 * @return string
 */
function et_theme_path() {
  global $base_url;
  return str_replace($base_url, '', path_to_theme());
}

/**
 * Returns an array containing the parts of the request uri with slashes trimmed and query removed. The alias() function
 * should be used instead of this in 99% of situations.
 *
 * @param string $uri - The uri to work from, defaults to current (NULL)
 * @return array
 */
function et_url_parts($uri = NULL) {
  if (!$uri) {
    $uri = explode('?', request_uri());
    return explode('/', trim($uri[0], '/'));
  }
  else {
    return explode('/', trim($uri, '/'));
  }

  return NULL;
}

/**
 * Use like arg(), this function works off of the alias instead of the path.
 *
 * @param int $x - The part to return
 * @param string $uri - The uri to work from, defaults to current (NULL)
 * @return string | boolean
 */
function et_alias($x = NULL, $uri = NULL) {
  if ($x === NULL) {
    return implode('/', url_parts($uri));
  }

  $parts = url_parts($uri);
  if (isset($parts[$x])) {
    return $parts[$x];
  }
  else {
    return FALSE;
  }
}

/**
 * Returns a mlid for a given page from the given menu. This can be useful for finding information about the menu item
 * or finding its child pages. NOTE: this function will only return the first occurance of the item in the menu.
 *
 * @param string $path - The Drupal path to the page
 * @param string $menu - Optional - The menu to search
 * @return FALSE / int (mlid)
 */
function et_get_mlid($path, $menu = 'main-menu') {
  $mlid = NULL;

  $query = db_select('menu_links', 'ml');
  $query->condition('ml.link_path', $path, '=')
        ->condition('ml.menu_name', $menu, '=')
        ->fields('ml', array('mlid'));

  $result = $query->execute()->fetchCol();
  if ($result) {
    $mlid = $result[0];
  }

  return $mlid;
}

/**
 * Finds the mlid in the given menu
 * @param integer $mlid
 * @param array $link
 * @return array | null
 */
function et_find_mlid_in_menu($mlid, $link) {
  if ($mlid == $link['link']['mlid']) {
      return $link;
  }
  else {
    foreach ($link['below'] as $k => $item) {
      $response = find_mlid_in_menu($mlid, $item);
      if ($response) {
        return $response;
      }
    }
  }
}

/**
 * Returns an array of the child pages of the given mlid. Use get_mlid() to get the mlid to search from. This function
 * is useful for landing pages etc.
 *
 * @param int $mlid - The menu link id, probably from get_mlid()
 * @param string $menu - Optional - The menu to search
 * @return array
 */
function et_get_menu_children($mlid, $menu = 'main-menu') {
  $tree = menu_tree_all_data($menu);
  $children = array();
  if ($mlid) {
    foreach ($tree as $branch) {
      $check = _find_mlid_in_menu($mlid, $branch);

      if ($check) {
        $branch = $check;
        foreach ($branch['below'] as $twig) {
          $alias = url_parts($twig['link']['link_path']);
          if ($alias[0] == 'node') {
            $n = node_load($alias[1]);
            $children[$n->title . ':' . $n->nid] = $n;
          }
        }

        ksort($children);
      }
    }
  }

  return $children;
}

/**
 * Helper function for get_menu_children() that recursively search an menu, this should not be called directly.
 *
 * @param int $mlid - The menu link id
 * @param array $link - The menu tree item
 * @return array | null
 */
function et_find_mlid_in_menu($mlid, $link) {
  if ($mlid == $link['link']['mlid']) {
      return $link;
  }
  else {
    foreach ($link['below'] as $k => $item) {
      $response = _find_mlid_in_menu($mlid, $item);
      if ($response) {
        return $response;
      }
    }
  }
}

/**
 * Returns a clean and simple array of the items in a menu, no mess, no fuss.
 *
 * @param string $menu - Optional - The menu to return
 * @return array
 */
function et_get_clean_menu($menu = 'main-menu') {
  $menu = menu_tree_all_data($menu);
  
  if ($menu) {
    $menu_clean = array();
    foreach ($menu as $item) {
      if (array_key_exists('link', $item) && $item['link']['hidden'] == 0) {
        $menu_clean[] = _get_clean_menu_item($item);
      }
    }

    if ($menu_clean) {
      return $menu_clean;
    }
  }

  return FALSE;
}

/**
 * Helper function for get_clean_menu(). This function should not be called directly.
 *
 * @param array $item - The menu tree item
 * @return array
 */
function et_get_clean_menu_item($item) {
  if (array_key_exists('link', $item)) {
    $link = array(
      'title' => $item['link']['link_title'],
      'path' => $item['link']['link_path'],
      'alias' => drupal_get_path_alias($item['link']['link_path']),
      'language' => (isset($item['link']['language'])) ? $item['link']['language'] : language_default(),
      'children' => array(),
    );
    
    if (array_key_exists('below', $item)) {
      foreach ($item['below'] as $child) {
        $link['children'][] = _get_clean_menu_item($child);
      }
    }

    return $link;
  }
}

/**
 * Formats a variable so it can be inserted into a field.
 * @param array $data
 * @param string $key
 * @return array
 */
function et_field_format($data, $key = 'value', $range = FALSE, $lang = LANGUAGE_NONE, $format = 'none') {
  $x = 0;
  $field = array($lang => array());
  if (!is_array($data)) {
    $data = array($data);
  }

  foreach ($data as $item) {
    $x++;
    if ($range) {
      if ($x > 1 && trim($item)) {
        $field[$lang][0][$key . $x] = trim($item);
      }
      elseif (trim($item)) {
        $field[$lang][0][$key] = trim($item);
      }
    }
    elseif (trim($item)) {
      if ($format != 'none')
        $field[$lang][] = array($key => utf8_encode(trim($item)), 'format' => $format);
      else
        $field[$lang][] = array($key => utf8_encode(trim($item)));
    }
  }

  return $field;
}

/**
 * Returns the raw end value for a field
 * @param string $field
 * @param string $entity
 * @param string $field_format
 * @param string $entity_type
 * @return string | NULL
 */
function et_get_raw_value($field, $entity, $field_format = 'safe_value', $entity_type = 'node', $resolve_tids = TRUE) {
  $data = field_get_items($entity_type, $entity, $field, $entity->language);
  $value = array();

  if ($data) {
    foreach ($data as $v) {
      if (isset($v[$field_format]) && $v[$field_format]) {
        if ($field_format == 'tid' && $resolve_tids) {
          $value[] = get_term_name($v[$field_format]);
        }
        else {
          $value[] = $v[$field_format];
        }
      }
      elseif (isset($v['value']) && $v['value']) {
        $value[] = $v['value'];
      }

      if ($value) {
        if (count($value) === 1) {
          $value = $value[0];
        }
        return $value;
      }
      else {
        return NULL;
      }
    }
  }
  else {
    return NULL;
  }
}

/**
* Instead of using safe_value use this
* @param type $node
* @param type $field_name
* @param type $delta
* @return type
*/
function et_get_field_value($entity, $field_name, $delta, $entity_type = 'node') {

  $field = field_get_items($entity_type, $entity, $field_name);
  $output = field_view_value($entity_type, $entity, $field_name, $field[$delta]);
  if (isset($output['#markup'])) {
    return $output["#markup"];
  }
  else {
    return '';
  }
}

/**
* Get's an image from a field collection
* @param type $node
* @param type $field_name
* @param type $delta
* @return type
*/
function et_get_field_collection_image($entity, $field_name, $delta, $entity_type = 'node') {
  
  $field = field_get_items($entity_type, $entity, $field_name);
  $output = field_view_value($entity_type, $entity, $field_name, $field[$delta]);
  
  return $output['#item'];
}

/**
 * Trims the string at a word boundry
 * @param string $str
 * @param length $n
 * @param string $delim
 * @return string 
 */
function et_neat_trim($str, $n = 200, $delim='&hellip;') {
  $str = strip_tags($str);
  $len = strlen($str);
  if ($len > $n) {
    preg_match('/(.{' . $n . '}.*?)\b/', $str, $matches);
    if ($matches[1] && isset($matches[1])) {
      return rtrim($matches[1]) . $delim;
    }
  }
  else {
    return $str;
  }
}

/**
 * Strips non alpha numberic characters except -_+ spaces are converted to hyphens
 * and the string is forced to lower case.
 * @param string $str - the raw string
 * @return strign - the formatted string
 */
function et_strip_non_alphanumeric($str) {
  $str = strtolower(str_replace(' ', ' ', preg_replace("/[^a-zA-Z0-9\-_+\s]/", "", $str)));
  return $str;
}

/**
 * Returns the number of days in a given month (and in the case of February, for the given year).
 * @param string $year
 * @param string $month
 * @return date
 */
function days_in_month($year, $month) { 
  return date("t", strtotime($year . "-" . $month . "-01")); 
}

/**
 * Finds all Country Name & Code from Client IP Address
 *
 * @return
 *   An array of country name & code
 */
function et_get_country_from_ip() {
  include_once "ip2country/ip2country.php";
  
  global $databases;
  $ip2c = new ip2country();
  $ip2c->mysql_host = $databases['default']['default']['host'];
  $ip2c->db_user = $databases['default']['default']['username'];
  $ip2c->db_pass = $databases['default']['default']['password'];
  $ip2c->db_name = $databases['default']['default']['database'];
  $ip2c->table_name = 'ip2c';
  
  return array('name' => $ip2c->get_country_name(),
               'code' => $ip2c->get_country_code()
              );
}

/**
 * Fixes the drupal cache when random strings are added to it
 * @param cache $cache
 * @return boolean
 */
function et_good_cache($cache) {
  if ($cache && ($cache->data <> 'a:0:{}' && !strstr($cache->data, 'a:0:{}'))) { 
      return TRUE;
  }
  return FALSE;
}

/**
 * Generates a built list of spotlights for a page
 *
 * @return
 *   A built list of spotlights
 */
function et_build_spotlights($node) {
  $spotlights = '';
  
  return $spotlights;
}

/**
 * If the user is an administrator an edit button is displayed
 * 
 * @param object $user
 * @return string - An edit button
 */
function et_show_edit($user) {
  if ($user->uid == 1 || in_array('administrator', $user->roles) || in_array('ve administrator', $user->roles) ) {
    $path = current_path();
    if (!strstr($path, 'node/') && !strstr($path, 'taxonomy/')) {
      $path = '';
    }
    else {
      $language_path = '';
      if (isset($_SESSION['selected_language']) && $_SESSION['selected_language'] != 'en') {
        $language_path = $_SESSION['selected_language'] . '/';  
      }
      $path = '/' . $path . '/edit?destination=' . $language_path . $path;
    }
    if (strlen($path)) {
      echo '<div class="admin"><a class="news-footer" href="' . $path . '">Edit this page</a></div>';
    }
  }
}

/**
 * Takes the twitter user and returns the latest tweets for that user for set page type
 *
 * @return
 *   Returns html
 */
function et_get_twitter_block($twitter_user, $type) {
  $comments = '';

  return $comments;
}


/**
 * Takes an array of tags, takes the fieldset with the tags, and takes the individual field
 *
 * @return
 *   Fills the array 'tags' with specific tags
 */
function et_get_fieldset_tags(&$tags, $fieldset_location, $fieldset_field, $id_only = FALSE) {
  $fieldset_tags = $fieldset_location->$fieldset_field;
  if (isset ($fieldset_tags['und'])) {
    if (!$id_only) {
      foreach ($fieldset_tags['und'] as $tag) {
        array_push($tags, $tag);
      }
    }
    else {
      foreach ($fieldset_tags['und'] as $tag) {
        array_push($tags, $tag['tid']);
      }
    }
  }
}

/*
 * File size conversion to human readable format
 * @param int $bytes
 * @return
 *  Returns a string of the size of a file with a human readable byte size 
 *  appended
 */
function et_format_size_units($bytes) {
  if ($bytes >= 1073741824) {
    $bytes = number_format($bytes / 1073741824, 2) . ' GB';
  }
  elseif ($bytes >= 1048576) {
    $bytes = number_format($bytes / 1048576, 2) . ' MB';
  }
  elseif ($bytes >= 1024) {
    $bytes = number_format($bytes / 1024, 2) . ' KB';
  }
  elseif ($bytes > 1) {
    $bytes = $bytes . ' bytes';
  }
  elseif ($bytes == 1) {
    $bytes = $bytes . ' byte';
  }
  else {
    $bytes = '0 bytes';
  }

  return $bytes;
}

/*
 * Function to get a counter for the current pager
 * @param view $view - the current view
 * @return
 *  returns the pagers output and the start integer for the current set
 *  of results being viewed
 */
function et_get_pager_counter($view) {
  global $pager_page_array, $pager_total_items, $pager_total;
  $this_pager = $view->display_handler->get_option('pager');
  $items_per_page = $this_pager['options']['items_per_page'];
  $pager_output = '';
  
  // Fix for FAQ's, it isn't showing the $items_per_page
  if ($view->name == 'all_faqs') {
    $items_per_page = 10;
  }
  
  if ($pager_total[0] == 1) { // Number of pages == 1
    $pager_output .= "<p>Showing " . $pager_total_items[0] . '</p>';
    $start = 0;
  }
  else{
     // Page number is zero-based (first page is 0)
    // Multiply pager_limit by page number (eg 0, 15, 30) and add 1 to get first item
    $start = 1 + ($pager_page_array[0] * $items_per_page);
    // Multiply pager_limit by page number + 1 (eg 15, 30, 45) to get last item
    $end = (1 + $pager_page_array[0]) * $items_per_page;
    // Use total items count if this is less than that
    if ($end > $pager_total_items[0]) $end = $pager_total_items[0];
    
    // Change language so that singular is used if only one result
    if (count($view->result) == 1) {
      $pager_output .= "<p>Result $end of " . $pager_total_items[0] . '</p>';
    }
    else {
      $pager_output .= "<p>Results $start-$end of " . $pager_total_items[0] . '</p>'; 
    }
  }
  
  // Return the pager markup and the first item number of the pager
  return array($pager_output, $start);
}

/*
 * Function to check if a dates format is value
 * @param string $value - the date
 * @return bool - returns a boolean indicating if the date is valid
 */
function et_is_valid_date($value, $format = 'dd.mm.yyyy') { 
  if (strlen($value) >= 6 && strlen($format) == 10) {
    // find separator. Remove all other characters from $format 
    $separator_only = str_replace(array('m', 'd', 'y'), '', $format); 
    $separator = $separator_only[0]; // separator is first character 
    if ($separator && strlen($separator_only) == 2) {
      // make regex 
      $regexp = str_replace('mm', '(0?[1-9]|1[0-2])', $format); 
      $regexp = str_replace('dd', '(0?[1-9]|[1-2][0-9]|3[0-1])', $regexp); 
      $regexp = str_replace('yyyy', '(19|20)?[0-9][0-9]', $regexp); 
      $regexp = str_replace($separator, "\\" . $separator, $regexp); 
      if ($regexp != $value && preg_match('/' . $regexp . '\z/', $value)) {
        // check date 
        $arr = explode($separator, $value);
        $day = $arr[0]; 
        $month = $arr[1]; 
        $year = $arr[2]; 
        if (@checkdate($month, $day, $year)) {
          return $year . '-' . $month . '-' . $day; 
        } 
      } 
    } 
  } 
  return FALSE; 
}

/**
 * Sends email
 * @param type $from
 * @param type $to
 * @param type $subject
 * @param type $message
 * @return bool - sent / not sent 
 */
function et_user_send_mail($from, $to, $subject, $message) {
  require_once('./sites/all/includes/class.phpmailer.php');
  
  $mail = new PHPMailer();
  $mail->IsSendmail();
  
  $mail->AddAddress($to);
  $mail->Subject = $subject;
  if (is_array($from)) {
    $mail->AddReplyTo($from[0], ucwords($from[1]));
    $mail->SetFrom($from[0], ucwords($from[1]));
  }
  else {
    $mail->AddReplyTo($from);
    $mail->SetFrom($from);
  }
  
  if (is_array($message)) {
    $mail->AltBody = $message[1];
    $mail->MsgHTML($message[0]);
  }
  else {
    $mail->AltBody = $message;
    $mail->MsgHTML($message);
  }
  
  if ($mail->Send()) {
    return TRUE;
  }
  else {
    return FALSE;
  }
}

/**
 * Renders blocks in a much more simplified manner
 * @param string $module
 * @param int $block_id
 * @return object rendered block
 */
function et_block_render($module, $block_id) {
  $block = block_load($module, $block_id);
  $block_content = _block_render_blocks(array($block));
  $build = _block_get_renderable_array($block_content);
  $block_rendered = drupal_render($build);
  return $block_rendered;
}

/**
 * Renders beans
 * @param int $bean_id
 * @return object rendered block
 */
function et_bean_render($bean_id) {
  $bean = bean_load($bean_id);
  if (FALSE !== $bean) {
    return drupal_render(bean_view($bean));
  }
  else {
    return '';
  }
}

/*
 * Renders a time in the format of 'x hours ago'
 * @param timezone $ptime - Timezone formatted time string 2013-09-23T07:41:50+0000
 * @return string $time - Time since
 */
function et_time_elapsed_string($ptime) {
  $etime = time() - strtotime($ptime);
  
  if ($etime < 1) {
    return '0 seconds';
  }
  
  $a = array( 12 * 30 * 24 * 60 * 60  =>  'year',
              30 * 24 * 60 * 60       =>  'month',
              24 * 60 * 60            =>  'day',
              60 * 60                 =>  'hour',
              60                      =>  'minute',
              1                       =>  'second'
              );

  foreach ($a as $secs => $str) {
    $d = $etime / $secs;
    if ($d >= 1) {
      $r = round($d);
      return $r . ' ' . $str . ($r > 1 ? 's' : '') . ' ago';
    }
  }
}

/*
 * Formats a string with a URL to make the URL clickable
 * @param string $string - String to format
 * @retutn string $string - Formatted string
 */
function et_string_hyperlink_format($string) {
  $string = preg_replace('"\b(http://\S+)"', '<a href="$1">$1</a>', $string);
  
  return $string;
}

/*
 * Formats a string into Tite Case - ignoring small words
 * @param string $title - Item to convert
 * @retutn string $newtitle - Formatted string
 */
function et_strtotitle($title) {
  // Our array of 'small words' which shouldn't be capitalised if
  // they aren't the first word. Add your own words to taste.
  $smallwordsarray = array('of', 'a', 'the', 'and', 'an', 'or', 'nor', 'but', 'is', 'if', 'then', 'else', 'when',
                           'at', 'from', 'by', 'on', 'off', 'for', 'in', 'out', 'over', 'to', 'into', 'with'
                          );
  
  // Split the string into separate words & set to lowercase
  $words = explode(' ', strtolower(trim($title)));
  
  foreach ($words as $key => $word) {
    // If this word is the first, or it's not one of our small words, capitalise it  with ucwords().
    if ($key == 0 or !in_array($word, $smallwordsarray)) {
      $words[$key] = ucwords($word);
    }
  }
  
  // Join the words back into a string
  $newtitle = str_replace('  ', ' ', implode(' ', $words));
  return $newtitle;
}

/*
 * Function to compare months in an array
 */
function et_monthCompare($a, $b) {
  //$months = array('JAN' => 1, 'FEB' =>2,'MAR' => 3,'APR' => 4,'MAY' => 5,'JUN' => 6,'JULY' => 7,'AUG' => 8, 'SEP' => 9, 'OCT' => 10, 'NOV' => 11, 'DEC' => 12);
  $aMonth = date("m Y", $a);
  $bMonth = date("m Y", $b);
  
  if ($a == $b) {
    return 0;
  }
  
  return ($aMonth > $bMonth) ? 1 : -1;
}

function et_clean_html_values($string) {
  $string = str_replace('<p></p>', '', $string);
  return $string;
}

/*
 * Normalize the line endings first (windows style to unix style):
 * 
 * @param string $str
 * @return string $s
 */
function et_normalise_string($str) {
  // Normalize line endings
  // Convert all line-endings to UNIX format
  $s = str_replace("\r\n", "\n", $str);
  $s = str_replace("\r", "\n", $s);
  // Don't allow out-of-control blank lines
  $s = preg_replace("/\n{2,}/", "\n\n", $s);
  return $s;
}

/*
 * Function to implement dBug for a higher level of debugging
 * in arrays or objects
 */
function et_dBug_vars() {
 new dBug(get_defined_vars());
}
